"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _cache = require("./cache");

var _cache2 = _interopRequireDefault(_cache);

var _uuid = require("uuid");

var _uuid2 = _interopRequireDefault(_uuid);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Promise = require("bluebird");
var pretty = require("prettyjson");

var urlLib = require("url");
var pointer = require("json-pointer");
var ws = require("./websocket");
var axios = require("axios");
var _TOKEN = require("./token");
//const error = require('debug')('oada-cache:index:error');
//const info = require('debug')('oada-cache:index:info');

process.on('unhandledRejection', function (reason, p) {
  console.log('------Unhandled Rejection - Fix Me!-------');
  console.log(reason);
});

var connect = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee26(_ref) {
    var _makeResourceAndLink = function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref3, waitTime) {
        var path = _ref3.path,
            data = _ref3.data,
            headers = _ref3.headers;
        var linkReq, resReq, link, pathPieces, parentPath, response, newHeaders, resource;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                //info('_makeResourceAndLink', path, data)
                data._id = _lodash2.default.clone(data._id) || "resources/" + (0, _uuid2.default)();

                linkReq = {
                  path: path,
                  type: data._type,
                  headers: headers,
                  data: { _id: data._id }
                };
                // Create a versioned link if the tree specifies one.

                if ('_rev' in data) {
                  linkReq.data._rev = 0;
                }
                // We don't want to attempt to set the rev when we put the resource

                resReq = {
                  path: "/" + data._id,
                  type: data._type,
                  data: data
                };
                _context.prev = 4;
                _context.next = 7;
                return put(linkReq);

              case 7:
                link = _context.sent;
                _context.next = 50;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](4);

                if (!(_context.t0.response && _context.t0.response.status === 412)) {
                  _context.next = 49;
                  break;
                }

                pathPieces = path.split("/");
                parentPath = pathPieces.splice(0, pathPieces.length - 1).join("/");
                // Wait time increases: 1s, 2s, 4s, 8s, 16s. Throw after 16s.

                if (!(waitTime > 16000)) {
                  _context.next = 17;
                  break;
                }

                throw _context.t0;

              case 17:
                _context.prev = 17;
                _context.next = 20;
                return NOCACHEREQUEST({
                  method: "get",
                  url: DOMAIN + parentPath,
                  headers: { Authorization: "Bearer " + TOKEN }
                });

              case 20:
                response = _context.sent;
                _context.next = 29;
                break;

              case 23:
                _context.prev = 23;
                _context.t1 = _context["catch"](17);

                waitTime = waitTime || 1000;
                _context.next = 28;
                return Promise.delay(waitTime);

              case 28:
                return _context.abrupt("return", _makeResourceAndLink({ path: path, data: data, headers: headers }, waitTime * 2));

              case 29:
                if (!response.data[pathPieces[pathPieces.length - 1]]) {
                  _context.next = 41;
                  break;
                }

                resReq.data._id = response.data[pathPieces[pathPieces.length - 1]]._id;
                resReq.path = '/' + resReq.data._id;
                // Concurrent put, delete, put (delete.test.js #15) can produce situations where _id is undefined

                if (resReq.data._id) {
                  _context.next = 39;
                  break;
                }

                waitTime = waitTime || 1000;
                _context.next = 36;
                return Promise.delay(waitTime);

              case 36:
                newHeaders = _lodash2.default.cloneDeep(headers);
                //TODO: use if-match headers???

                newHeaders['if-match'] = parseInt(response.headers['x-oada-rev']);
                return _context.abrupt("return", _makeResourceAndLink({ path: path, data: data, headers: newHeaders }, waitTime * 2));

              case 39:
                _context.next = 47;
                break;

              case 41:
                // The key does not yet exist, adjust the if-match and try again.
                waitTime = waitTime || 1000;
                _context.next = 44;
                return Promise.delay(waitTime);

              case 44:
                newHeaders = _lodash2.default.cloneDeep(headers);

                newHeaders['if-match'] = parseInt(response.headers['x-oada-rev']);
                return _context.abrupt("return", _makeResourceAndLink({ path: path, data: data, headers: newHeaders }, waitTime * 2));

              case 47:
                _context.next = 50;
                break;

              case 49:
                throw _context.t0;

              case 50:
                // Delete the _rev  and _id keys. No need for them in the resource object. They will break things.
                if ('_rev' in data) delete resReq.data._rev;
                _context.next = 53;
                return put(resReq);

              case 53:
                resource = _context.sent;
                return _context.abrupt("return", { link: link, resource: resource });

              case 55:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 10], [17, 23]]);
      }));

      return function _makeResourceAndLink(_x2, _x3) {
        return _ref4.apply(this, arguments);
      };
    }();

    // Construct the request object and catch any 401s (expired token)
    var _buildRequest = function () {
      var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(_ref7) {
        var method = _ref7.method,
            url = _ref7.url,
            path = _ref7.path,
            headers = _ref7.headers,
            data = _ref7.data,
            type = _ref7.type;
        var req;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(!path && !url)) {
                  _context3.next = 2;
                  break;
                }

                throw new Error("Either path or url must be specified.");

              case 2:
                if (!url) {
                  _context3.next = 9;
                  break;
                }

                if (!/^\//.test(url)) {
                  _context3.next = 7;
                  break;
                }

                url = domain + url;
                _context3.next = 9;
                break;

              case 7:
                if (!(url.indexOf(domain) !== 0)) {
                  _context3.next = 9;
                  break;
                }

                throw new Error("'url' key must begin with the domain used to connect");

              case 9:
                method = method.toLowerCase();
                req = {
                  method: method,
                  url: url || DOMAIN + path,
                  headers: { authorization: "Bearer " + TOKEN }
                };

                if (/\/$/.test(req.url)) req.url = req.url.slice(0, req.url.length - 1);

                //handle headers
                (0, _keys2.default)(headers || {}).forEach(function (header) {
                  req.headers[header.toLowerCase()] = headers[header];
                });

                if (method === "put" || method === "post") {
                  req.headers["content-type"] = req.headers["content-type"] || type || data._type;
                  req.data = data;
                }

                if (method === "delete") {
                  req.headers["content-type"] = req.headers["content-type"] || type;
                }
                req.requestStack = new Error().stack;
                return _context3.abrupt("return", req);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function _buildRequest(_x5) {
        return _ref8.apply(this, arguments);
      };
    }();

    var _sendRequest = function () {
      var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(req) {
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                return _context4.abrupt("return", REQUEST(req));

              case 4:
                _context4.prev = 4;
                _context4.t0 = _context4["catch"](0);

                if (!(_context4.t0 && _context4.t0.response.status === 401)) {
                  _context4.next = 10;
                  break;
                }

                _context4.next = 9;
                return reconnect();

              case 9:
                return _context4.abrupt("return", REQUEST(req));

              case 10:
                throw _context4.t0;

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 4]]);
      }));

      return function _sendRequest(_x6) {
        return _ref9.apply(this, arguments);
      };
    }();

    var _treeWalk = function () {
      var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(url, tree, data, obj, beforeCb, afterCb) {
        var bef;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!beforeCb) {
                  _context7.next = 6;
                  break;
                }

                _context7.next = 3;
                return beforeCb(url, tree, data, obj);

              case 3:
                _context7.t0 = _context7.sent;
                _context7.next = 7;
                break;

              case 6:
                _context7.t0 = { data: data, obj: obj };

              case 7:
                bef = _context7.t0;

                data = bef.data;
                obj = bef.obj;

                return _context7.abrupt("return", Promise.map((0, _keys2.default)(data || {}), function () {
                  var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(key) {
                    var nextTree, res;
                    return _regenerator2.default.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            if (!((0, _typeof3.default)(data[key]) === "object")) {
                              _context5.next = 15;
                              break;
                            }

                            if (!tree[key]) {
                              _context5.next = 5;
                              break;
                            }

                            nextTree = tree[key];
                            _context5.next = 10;
                            break;

                          case 5:
                            if (!tree['*']) {
                              _context5.next = 9;
                              break;
                            }

                            nextTree = tree['*'];

                            //Leave alone data for any keys that are not present in tree. Do not
                            //pursue these keys any further.
                            _context5.next = 10;
                            break;

                          case 9:
                            return _context5.abrupt("return");

                          case 10:
                            _context5.next = 12;
                            return _treeWalk(url + '/' + key, nextTree, data[key], obj, beforeCb, afterCb);

                          case 12:
                            res = _context5.sent;

                            data[key] = res.data;
                            obj = res.obj;

                          case 15:
                            return _context5.abrupt("return");

                          case 16:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5, this);
                  }));

                  return function (_x13) {
                    return _ref11.apply(this, arguments);
                  };
                }()).then((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
                  return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          if (!afterCb) {
                            _context6.next = 6;
                            break;
                          }

                          _context6.next = 3;
                          return afterCb(url, tree, data, obj);

                        case 3:
                          _context6.t0 = _context6.sent;
                          _context6.next = 7;
                          break;

                        case 6:
                          _context6.t0 = { data: data, obj: obj };

                        case 7:
                          return _context6.abrupt("return", _context6.t0);

                        case 8:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6, this);
                }))));

              case 11:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function _treeWalk(_x7, _x8, _x9, _x10, _x11, _x12) {
        return _ref10.apply(this, arguments);
      };
    }();

    // walk down the tree to


    //TODO: patched up uncaughtrejection warning on _sendRequest with try/catch
    //but need to reevaluate better code structuring
    var get = function () {
      var _ref19 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13(_ref18) {
        var url = _ref18.url,
            path = _ref18.path,
            headers = _ref18.headers,
            watch = _ref18.watch,
            tree = _ref18.tree;
        var req, watchResponse, response, subTree, pieces, treePath, stuff;
        return _regenerator2.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return _buildRequest({ method: "get", url: url, path: path, headers: headers });

              case 2:
                req = _context13.sent;

                // If a tree is supplied, recursively GET data according to the data tree
                // The tree must be rooted at /bookmarks.

                watchResponse = void 0;
                // TODO: shouldn't request twice for normal tree get...

                _context13.prev = 4;
                _context13.next = 7;
                return _sendRequest(req);

              case 7:
                response = _context13.sent;
                _context13.next = 13;
                break;

              case 10:
                _context13.prev = 10;
                _context13.t0 = _context13["catch"](4);
                throw _context13.t0;

              case 13:
                subTree = void 0;
                // Use the tree to construct the subTree to be potentially used in both the
                // watch as well as the recursiveGet

                if (!tree) {
                  _context13.next = 20;
                  break;
                }

                pieces = urlLib.parse(req.url).path.replace(/^\//, "").split("/");
                treePath = _convertSetupTreePath(pieces, tree);

                if (pointer.has(tree, treePath)) {
                  _context13.next = 19;
                  break;
                }

                throw new Error("The path does not exist on the given tree.");

              case 19:
                subTree = pointer.get(tree, treePath);

              case 20:
                if (!watch) {
                  _context13.next = 34;
                  break;
                }

                path = path || urlLib.parse(url).path;
                req.headers["x-oada-rev"] = response.data._rev;
                console.log('SENDING THIS REEVVVVVVVVVVVVVVV', response.data._rev);
                if (tree) {
                  if (!watch.payload) watch.payload = {};
                  watch.payload.tree = subTree;
                }
                _context13.prev = 25;
                _context13.next = 28;
                return _watch({
                  headers: req.headers,
                  path: path,
                  callback: watch.func || watch.callback,
                  payload: watch.payload
                });

              case 28:
                watchResponse = _context13.sent;
                _context13.next = 34;
                break;

              case 31:
                _context13.prev = 31;
                _context13.t1 = _context13["catch"](25);
                throw _context13.t1;

              case 34:
                if (!tree) {
                  _context13.next = 57;
                  break;
                }

                _context13.prev = 35;

                if (!(watch && watchResponse.resource)) {
                  _context13.next = 42;
                  break;
                }

                _context13.next = 39;
                return _recursiveGet(req.url, subTree, watchResponse.resource, true);

              case 39:
                stuff = _context13.sent;
                _context13.next = 45;
                break;

              case 42:
                _context13.next = 44;
                return _recursiveGet(req.url, subTree, response.data, true);

              case 44:
                stuff = _context13.sent;

              case 45:
                response.data = stuff.data;
                response.cached = stuff.cached;
                _context13.next = 57;
                break;

              case 49:
                _context13.prev = 49;
                _context13.t2 = _context13["catch"](35);
                // catch 404s because ... ?
                console.log('ERA came from', req);
                console.log('ERA', _context13.t2);

                if (!(_context13.t2.response && _context13.t2.response.status === 404)) {
                  _context13.next = 56;
                  break;
                }

                _context13.next = 57;
                break;

              case 56:
                throw _context13.t2;

              case 57:
                return _context13.abrupt("return", response);

              case 58:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this, [[4, 10], [25, 31], [35, 49]]);
      }));

      return function get(_x27) {
        return _ref19.apply(this, arguments);
      };
    }(); //get

    var _recursiveGet = function () {
      var _ref20 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15(url, tree, data, cached) {
        var got;
        return _regenerator2.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!tree._type) {
                  _context15.next = 6;
                  break;
                }

                _context15.next = 3;
                return get({
                  url: url,
                  headers: '_rev' in data ? { 'x-oada-rev': data._rev } : {}
                });

              case 3:
                got = _context15.sent;

                data = got.data;
                cached = got.cached ? got.cached : false;

              case 6:
                return _context15.abrupt("return", Promise.map((0, _keys2.default)(data || {}), function () {
                  var _ref21 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14(key) {
                    var res;
                    return _regenerator2.default.wrap(function _callee14$(_context14) {
                      while (1) {
                        switch (_context14.prev = _context14.next) {
                          case 0:
                            if (!((0, _typeof3.default)(data[key]) === "object")) {
                              _context14.next = 20;
                              break;
                            }

                            if (!tree[key]) {
                              _context14.next = 9;
                              break;
                            }

                            _context14.next = 4;
                            return _recursiveGet(url + "/" + key, tree[key], data[key], cached);

                          case 4:
                            res = _context14.sent;

                            cached = res.cached;
                            return _context14.abrupt("return", data[key] = res.data);

                          case 9:
                            if (!tree["*"]) {
                              _context14.next = 17;
                              break;
                            }

                            _context14.next = 12;
                            return _recursiveGet(url + "/" + key, tree["*"], data[key], cached);

                          case 12:
                            res = _context14.sent;

                            cached = res.cached;
                            return _context14.abrupt("return", data[key] = res.data);

                          case 17:
                            return _context14.abrupt("return");

                          case 18:
                            _context14.next = 21;
                            break;

                          case 20:
                            return _context14.abrupt("return");

                          case 21:
                          case "end":
                            return _context14.stop();
                        }
                      }
                    }, _callee14, this);
                  }));

                  return function (_x32) {
                    return _ref21.apply(this, arguments);
                  };
                }()).then(function () {
                  return { data: data, cached: cached };
                }));

              case 7:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      return function _recursiveGet(_x28, _x29, _x30, _x31) {
        return _ref20.apply(this, arguments);
      };
    }();

    // Identify the stored resources vs those that need to be setup.


    // Walk down the given path using the tree as a guide to create the necessary
    // resource breaks along the way.
    var _ensureTree = function () {
      var _ref23 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee17(_ref22) {
        var url = _ref22.url,
            tree = _ref22.tree,
            data = _ref22.data;
        var path, pieces, firstPath, storedTree, responses, ret, parentRev;
        return _regenerator2.default.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                path = urlLib.parse(url).path.replace(/^\//, "");
                pieces = path.replace(/\/$/, "").split("/"); // replace trailing slashes

                if (data._id) {
                  firstPath = _convertSetupTreePath(pieces, tree);

                  pointer.set(tree, firstPath + "/_id", data._id);
                }
                //    if (pointer.has(tree, treePath)) pointer.set(tree, treePath, _.merge(pointer.get(tree, treePath),data))
                storedTree = {};
                responses = [];
                // Find the deepest part of the path that exists. Once found, work back down.

                _context17.next = 7;
                return _findDeepestResources(pieces, tree, storedTree);

              case 7:
                ret = _context17.sent;

                // Create all the resources on the way down. ret.stored is an index. Slice
                // takes the length to slice, so no need to subtract 1.
                parentRev = ret._rev;
                _context17.next = 11;
                return Promise.mapSeries(pieces.slice(0, pieces.length - ret.stored), function () {
                  var _ref24 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee16(piece, j) {
                    var i, urlPath, treePath, content, resp;
                    return _regenerator2.default.wrap(function _callee16$(_context16) {
                      while (1) {
                        switch (_context16.prev = _context16.next) {
                          case 0:
                            i = ret.stored + 1 + j;
                            urlPath = "/" + pieces.slice(0, i + 1).join("/");
                            treePath = _convertSetupTreePath(pieces.slice(0, i + 1), tree);

                            if (!(pointer.has(tree, treePath + "/_type") && i <= ret.setup)) {
                              _context16.next = 14;
                              break;
                            }

                            _context16.next = 6;
                            return _replaceLinks(pointer.get(tree, treePath));

                          case 6:
                            content = _context16.sent;
                            _context16.next = 9;
                            return _makeResourceAndLink({
                              path: urlPath,
                              data: _lodash2.default.cloneDeep(content),
                              headers: { "if-match": parentRev }
                            });

                          case 9:
                            resp = _context16.sent;

                            parentRev = resp.resource.headers["x-oada-rev"];
                            pointer.set(storedTree, urlPath, content);
                            resp.path = urlPath;
                            responses.push(resp);

                          case 14:
                          case "end":
                            return _context16.stop();
                        }
                      }
                    }, _callee16, this);
                  }));

                  return function (_x34, _x35) {
                    return _ref24.apply(this, arguments);
                  };
                }());

              case 11:
                return _context17.abrupt("return", responses);

              case 12:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      return function _ensureTree(_x33) {
        return _ref23.apply(this, arguments);
      };
    }();

    var _recursiveDelete = function () {
      var _ref27 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee20(url, tree, data) {
        var got;
        return _regenerator2.default.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                if (!tree._type) {
                  _context20.next = 13;
                  break;
                }

                _context20.prev = 1;
                _context20.next = 4;
                return get({
                  url: url
                });

              case 4:
                got = _context20.sent;

                data = got.data;
                _context20.next = 13;
                break;

              case 8:
                _context20.prev = 8;
                _context20.t0 = _context20["catch"](1);

                if (!(_context20.t0.status === 404)) {
                  _context20.next = 13;
                  break;
                }

                data = {};
                return _context20.abrupt("return");

              case 13:
                return _context20.abrupt("return", Promise.map((0, _keys2.default)(data || {}), function () {
                  var _ref28 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee18(key) {
                    var res;
                    return _regenerator2.default.wrap(function _callee18$(_context18) {
                      while (1) {
                        switch (_context18.prev = _context18.next) {
                          case 0:
                            if (!((0, _typeof3.default)(data[key]) === "object")) {
                              _context18.next = 18;
                              break;
                            }

                            if (!tree[key]) {
                              _context18.next = 8;
                              break;
                            }

                            _context18.next = 4;
                            return _recursiveDelete(url + "/" + key, tree[key], data[key]);

                          case 4:
                            res = _context18.sent;
                            return _context18.abrupt("return", data[key] = res.data);

                          case 8:
                            if (!tree["*"]) {
                              _context18.next = 15;
                              break;
                            }

                            _context18.next = 11;
                            return _recursiveDelete(url + "/" + key, tree["*"], data[key]);

                          case 11:
                            res = _context18.sent;
                            return _context18.abrupt("return", data[key] = res.data);

                          case 15:
                            return _context18.abrupt("return");

                          case 16:
                            _context18.next = 19;
                            break;

                          case 18:
                            return _context18.abrupt("return");

                          case 19:
                          case "end":
                            return _context18.stop();
                        }
                      }
                    }, _callee18, this);
                  }));

                  return function (_x39) {
                    return _ref28.apply(this, arguments);
                  };
                }()).then((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee19() {
                  var link;
                  return _regenerator2.default.wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          if (!tree._type) {
                            _context19.next = 23;
                            break;
                          }

                          _context19.prev = 1;

                          if (!data._id) {
                            _context19.next = 11;
                            break;
                          }

                          _context19.prev = 3;
                          _context19.next = 6;
                          return del({
                            path: '/' + data._id,
                            headers: { 'content-type': tree._type }
                          });

                        case 6:
                          _context19.next = 11;
                          break;

                        case 8:
                          _context19.prev = 8;
                          _context19.t0 = _context19["catch"](3);

                          console.log('aaaaaaaa', '/' + data._id, url, _context19.t0);

                        case 11:
                          _context19.next = 13;
                          return del({
                            url: url,
                            headers: {
                              'content-type': tree._type
                            }
                          });

                        case 13:
                          link = _context19.sent;
                          _context19.next = 21;
                          break;

                        case 16:
                          _context19.prev = 16;
                          _context19.t1 = _context19["catch"](1);

                          if (!(_context19.t1.response && _context19.t1.response.status === 404)) {
                            _context19.next = 21;
                            break;
                          }

                          data = {};
                          return _context19.abrupt("return", {
                            link: link || {},
                            data: data || {}
                          });

                        case 21:
                          _context19.next = 26;
                          break;

                        case 23:
                          if (!CACHE) {
                            _context19.next = 26;
                            break;
                          }

                          _context19.next = 26;
                          return CACHE.removeLookup({ url: url });

                        case 26:
                          return _context19.abrupt("return", {
                            link: link || {},
                            data: data || {}
                          });

                        case 27:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19, this, [[1, 16], [3, 8]]);
                }))));

              case 14:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this, [[1, 8]]);
      }));

      return function _recursiveDelete(_x36, _x37, _x38) {
        return _ref27.apply(this, arguments);
      };
    }();

    var del = function () {
      var _ref31 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee21(_ref30) {
        var url = _ref30.url,
            path = _ref30.path,
            type = _ref30.type,
            headers = _ref30.headers,
            tree = _ref30.tree,
            unwatch = _ref30.unwatch;
        var req, pieces, treePath, subTree, result;
        return _regenerator2.default.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return _buildRequest({
                  method: "delete",
                  url: url,
                  path: path,
                  type: type,
                  headers: headers
                });

              case 2:
                req = _context21.sent;

                if (!unwatch) {
                  _context21.next = 6;
                  break;
                }

                path = path || urlLib.parse(url).path;
                return _context21.abrupt("return", SOCKET.unwatch({
                  path: path,
                  headers: req.headers
                }));

              case 6:
                if (!tree) {
                  _context21.next = 16;
                  break;
                }

                pieces = urlLib.parse(req.url).path.replace(/^\//, "").split("/");
                treePath = _convertSetupTreePath(pieces, tree);

                if (pointer.has(tree, treePath)) {
                  _context21.next = 11;
                  break;
                }

                throw new Error("The path does not exist on the given tree.");

              case 11:
                //return get({url: req.url})
                subTree = pointer.get(tree, treePath);
                _context21.next = 14;
                return _recursiveDelete(req.url, subTree, {}, true);

              case 14:
                result = _context21.sent;
                return _context21.abrupt("return", result.link);

              case 16:
                if (req.headers["content-type"]) {
                  _context21.next = 18;
                  break;
                }

                throw new Error("content-type header must be specified.");

              case 18:
                return _context21.abrupt("return", _sendRequest(req));

              case 19:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      return function del(_x40) {
        return _ref31.apply(this, arguments);
      };
    }();

    // Ensure all resources down to the deepest resource are created before
    // performing a PUT.


    var put = function () {
      var _ref33 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee22(_ref32) {
        var url = _ref32.url,
            path = _ref32.path,
            data = _ref32.data,
            type = _ref32.type,
            headers = _ref32.headers,
            tree = _ref32.tree;
        var req, responses, pieces, treePath;
        return _regenerator2.default.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return _buildRequest({
                  method: "put",
                  url: url,
                  path: path,
                  data: data,
                  type: type,
                  headers: headers
                });

              case 2:
                req = _context22.sent;

                if (!tree) {
                  _context22.next = 10;
                  break;
                }

                _context22.next = 6;
                return _ensureTree({
                  url: req.url,
                  tree: _lodash2.default.cloneDeep(tree),
                  data: data
                });

              case 6:
                responses = _context22.sent;
                pieces = responses.length > 0 ? responses[responses.length - 1].path.replace(/^\//, "").split("/") : urlLib.parse(req.url).path.replace(/^\//, "").split("/");
                treePath = _convertSetupTreePath(pieces, tree) + "/_type";

                if (!req.headers["content-type"] && pointer.has(tree, treePath)) req.headers["content-type"] = _lodash2.default.clone(pointer.get(tree, treePath));

              case 10:
                if (req.headers["content-type"]) {
                  _context22.next = 12;
                  break;
                }

                throw new Error("content-type header must be specified.");

              case 12:
                return _context22.abrupt("return", _sendRequest(req).then(function (result) {
                  return result;
                }));

              case 13:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      return function put(_x41) {
        return _ref33.apply(this, arguments);
      };
    }();

    var resetCache = function () {
      var _ref34 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee23(name, expires) {
        return _regenerator2.default.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (CACHE) {
                  _context23.next = 2;
                  break;
                }

                return _context23.abrupt("return");

              case 2:
                _context23.next = 4;
                return CACHE.resetCache();

              case 4:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      return function resetCache(_x42, _x43) {
        return _ref34.apply(this, arguments);
      };
    }();

    var disconnect = function () {
      var _ref35 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee24() {
        return _regenerator2.default.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                if (!CACHE) {
                  _context24.next = 3;
                  break;
                }

                _context24.next = 3;
                return CACHE.db.close();

              case 3:
                //if (CACHE) await CACHE.db.destroy();
                if (SOCKET) SOCKET.close();
                //if (_token.isSet()) {
                _token.cleanUp();
                //}

              case 5:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      return function disconnect() {
        return _ref35.apply(this, arguments);
      };
    }();

    var reconnect = function () {
      var _ref36 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee25() {
        return _regenerator2.default.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return _token.renew();

              case 2:
                TOKEN = _context25.sent;

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      return function reconnect() {
        return _ref36.apply(this, arguments);
      };
    }();

    // get a token


    var domain = _ref.domain,
        options = _ref.options,
        cache = _ref.cache,
        token = _ref.token,
        websocket = _ref.websocket;

    var OFFLINE, CACHE, REQUEST, NOCACHEREQUEST, SOCKET, TOKEN, _token, DOMAIN, NAME, EXPIRES, _replaceLinks, _watch, _recursiveFilterChange, recursiveFilterChange, recursiveGet, recursiveDelete, _findDeepestResources, _convertSetupTreePath, _configureCache, post, socketApi, _getMemoryCache;

    return _regenerator2.default.wrap(function _callee26$(_context26) {
      while (1) {
        switch (_context26.prev = _context26.next) {
          case 0:
            _getMemoryCache = function _getMemoryCache() {
              if (CACHE) {
                return CACHE._getMemoryCache();
              } else {
                return {};
              }
            };

            post = function post(_ref26) {
              var url = _ref26.url,
                  path = _ref26.path,
                  data = _ref26.data,
                  type = _ref26.type,
                  headers = _ref26.headers,
                  tree = _ref26.tree;

              url = url || DOMAIN + path;
              url = url[url.length - 1] === "/" ? url + (0, _uuid2.default)() : url + "/" + (0, _uuid2.default)();
              return put({
                url: url,
                data: data,
                type: type,
                headers: headers,
                tree: tree
              });
            };

            _configureCache = function _configureCache(_ref25) {
              var name = _ref25.name,
                  req = _ref25.req,
                  expires = _ref25.expires;

              var res = (0, _cache2.default)({ name: name, req: req, expires: expires });
              REQUEST = res.api;
              CACHE = res;
              return;
            };

            _convertSetupTreePath = function _convertSetupTreePath(pathPieces, tree) {
              var newPieces = _lodash2.default.clone(pathPieces);
              newPieces = pathPieces.map(function (piece, i) {
                if (pointer.has(tree, "/" + newPieces.slice(0, i).join("/") + "/*")) {
                  newPieces[i] = "*";
                  return "*";
                } else {
                  return piece;
                }
              });
              return "/" + newPieces.join("/");
            };

            _findDeepestResources = function _findDeepestResources(pieces, tree, storedTree) {
              var stored = 0;
              var setup = void 0;
              var _rev;
              // Walk down the url in reverse order
              return Promise.mapSeries(pieces, function (piece, i) {
                var z = pieces.length - 1 - i; //use z to create paths in reverse order
                var urlPath = "/" + pieces.slice(0, z + 1).join("/");
                var treePath = _convertSetupTreePath(pieces.slice(0, z + 1), tree);
                // Check that its in the stored tree then look for deepest _resource_.
                // If successful, break from the loop by throwing
                if (pointer.has(tree, treePath + "/_type")) {
                  setup = setup || z;
                  if (pointer.has(storedTree, urlPath)) {
                    stored = _lodash2.default.clone(z);
                    throw new Error("stored");
                  }
                  return get({
                    path: urlPath
                  }).then(function (response) {
                    //TODO: Detect whether the returned data matches the given tree
                    pointer.set(storedTree, urlPath, {});
                    stored = _lodash2.default.clone(z);
                    _rev = response.headers["x-oada-rev"];
                    throw new Error("stored");
                  }).catch(function (err) {
                    if (/^stored/.test(err.message)) throw err;
                    return;
                  });
                } else return;
              }).catch(function (err) {
                // Throwing with a number error only should occur on success.
                if (/^stored/.test(err.message)) return { stored: stored, setup: setup };
              }).then(function () {
                return {
                  stored: stored,
                  setup: setup || 0,
                  _rev: _rev
                };
              });
            };

            recursiveDelete = function recursiveDelete(startingUrl, tree, data) {
              return _treeWalk(startingUrl, tree, data, undefined, function () {
                var _ref16 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(url, subTree, data) {
                  var got;
                  return _regenerator2.default.wrap(function _callee11$(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          if (!subTree._type) {
                            _context11.next = 17;
                            break;
                          }

                          _context11.prev = 1;
                          _context11.next = 4;
                          return get({
                            url: url
                          });

                        case 4:
                          got = _context11.sent;

                          data = got.data;
                          _context11.next = 15;
                          break;

                        case 8:
                          _context11.prev = 8;
                          _context11.t0 = _context11["catch"](1);

                          if (!(_context11.t0.status === 404)) {
                            _context11.next = 14;
                            break;
                          }

                          data = {};
                          // WASN'T THROWING HERE PREVIOUSLY
                          _context11.next = 15;
                          break;

                        case 14:
                          throw _context11.t0;

                        case 15:
                          _context11.next = 18;
                          break;

                        case 17:
                          return _context11.abrupt("return", { data: data });

                        case 18:
                        case "end":
                          return _context11.stop();
                      }
                    }
                  }, _callee11, this, [[1, 8]]);
                }));

                function recDeleteBefore(_x22, _x23, _x24) {
                  return _ref16.apply(this, arguments);
                }

                return recDeleteBefore;
              }(), function () {
                var _ref17 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12(url, data) {
                  var link;
                  return _regenerator2.default.wrap(function _callee12$(_context12) {
                    while (1) {
                      switch (_context12.prev = _context12.next) {
                        case 0:
                          if (!tree._type) {
                            _context12.next = 25;
                            break;
                          }

                          _context12.prev = 1;

                          if (!data._id) {
                            _context12.next = 11;
                            break;
                          }

                          _context12.prev = 3;
                          _context12.next = 6;
                          return del({
                            path: '/' + data._id,
                            headers: { 'content-type': tree._type }
                          });

                        case 6:
                          _context12.next = 11;
                          break;

                        case 8:
                          _context12.prev = 8;
                          _context12.t0 = _context12["catch"](3);

                          console.log('recursiveDelete error on delete resource', _context12.t0);

                        case 11:
                          _context12.next = 13;
                          return del({
                            url: url,
                            headers: {
                              'content-type': tree._type
                            }
                          });

                        case 13:
                          link = _context12.sent;
                          _context12.next = 23;
                          break;

                        case 16:
                          _context12.prev = 16;
                          _context12.t1 = _context12["catch"](1);

                          if (!(_context12.t1.response && _context12.t1.response.status === 404)) {
                            _context12.next = 22;
                            break;
                          }

                          data = {};
                          // WASN'T THROWING HERE PREVIOUSLY
                          _context12.next = 23;
                          break;

                        case 22:
                          throw _context12.t1;

                        case 23:
                          _context12.next = 28;
                          break;

                        case 25:
                          if (!CACHE) {
                            _context12.next = 28;
                            break;
                          }

                          _context12.next = 28;
                          return CACHE.removeLookup({ url: url });

                        case 28:
                          return _context12.abrupt("return", {
                            link: link || {},
                            data: data || {}
                          });

                        case 29:
                        case "end":
                          return _context12.stop();
                      }
                    }
                  }, _callee12, this, [[1, 16], [3, 8]]);
                }));

                function recDeleteAfter(_x25, _x26) {
                  return _ref17.apply(this, arguments);
                }

                return recDeleteAfter;
              }());
            };

            recursiveGet = function recursiveGet(startingUrl, tree, data, cached) {
              return _treeWalk(startingUrl, tree, { data: data, cached: cached }, function () {
                var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(url, subTree, data, obj) {
                  var got;
                  return _regenerator2.default.wrap(function _callee10$(_context10) {
                    while (1) {
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          if (!subTree._type) {
                            _context10.next = 6;
                            break;
                          }

                          _context10.next = 3;
                          return get({
                            url: url,
                            headers: '_rev' in data ? { 'x-oada-rev': data._rev } : {}
                          });

                        case 3:
                          got = _context10.sent;

                          data = got.data;
                          obj.cached = got.cached ? got.cached : false;

                        case 6:
                          return _context10.abrupt("return", { data: data, obj: obj });

                        case 7:
                        case "end":
                          return _context10.stop();
                      }
                    }
                  }, _callee10, this);
                }));

                function recGetBefore(_x18, _x19, _x20, _x21) {
                  return _ref15.apply(this, arguments);
                }

                return recGetBefore;
              }(), undefined);
            };

            recursiveFilterChange = function recursiveFilterChange(startingUrl, tree, changeBody) {
              return _treeWalk(startingUrl, tree, changeBody, undefined, function () {
                var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(url, subTree, data) {
                  var getTree, path, got;
                  return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          if (!((0, _keys2.default)(data).length === 1 && data._id || (0, _keys2.default)(data).length === 2 && Object.hasOwnProperty(data, '_rev') && data._id)) {
                            _context9.next = 8;
                            break;
                          }

                          getTree = {};
                          path = urlLib.parse(url).path;

                          pointer.set(getTree, path, subTree);
                          _context9.next = 6;
                          return get({
                            tree: getTree,
                            url: url
                          });

                        case 6:
                          got = _context9.sent;

                          data = got.data;

                        case 8:
                          return _context9.abrupt("return", { data: data });

                        case 9:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, _callee9, this);
                }));

                function retrieveLinkedData(_x15, _x16, _x17) {
                  return _ref14.apply(this, arguments);
                }

                return retrieveLinkedData;
              }());
            };

            _recursiveFilterChange = function _recursiveFilterChange(url, tree, data) {
              //Filter at resource breaks
              return Promise.map((0, _keys2.default)(data || {}), function () {
                var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(key) {
                  var res, rv;
                  return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          if (!((0, _typeof3.default)(data[key]) === "object")) {
                            _context8.next = 22;
                            break;
                          }

                          if (!tree[key]) {
                            _context8.next = 8;
                            break;
                          }

                          _context8.next = 4;
                          return _recursiveFilterChange(url + "/" + key, tree[key], data[key]);

                        case 4:
                          res = _context8.sent;
                          return _context8.abrupt("return", data[key] = res.data);

                        case 8:
                          if (!tree["*"]) {
                            _context8.next = 15;
                            break;
                          }

                          _context8.next = 11;
                          return _recursiveFilterChange(url + "/" + key, tree["*"], data[key]);

                        case 11:
                          res = _context8.sent;
                          return _context8.abrupt("return", data[key] = res.data);

                        case 15:
                          if (!data[key]._id) {
                            _context8.next = 20;
                            break;
                          }

                          rv = data[key]._rev ? data[key]._rev : false;

                          data[key] = { _id: data[key]._id };
                          if (rv) data[key]._rev = data[key]._rev;
                          return _context8.abrupt("return");

                        case 20:
                          _context8.next = 23;
                          break;

                        case 22:
                          return _context8.abrupt("return");

                        case 23:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8, this);
                }));

                return function (_x14) {
                  return _ref13.apply(this, arguments);
                };
              }()).then(function () {
                return { data: data };
              });
            };

            _watch = function _watch(_ref5) {
              var headers = _ref5.headers,
                  path = _ref5.path,
                  callback = _ref5.callback,
                  payload = _ref5.payload;

              if (SOCKET) {
                return SOCKET.watch({
                  path: path,
                  headers: headers
                }, function () {
                  var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(response) {
                    var filtered, watchPayload;
                    return _regenerator2.default.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!payload.tree) {
                              _context2.next = 5;
                              break;
                            }

                            _context2.next = 3;
                            return _recursiveFilterChange(DOMAIN + path, payload.tree, response.change.body);

                          case 3:
                            filtered = _context2.sent;

                            response.change.body = filtered.data;

                          case 5:
                            watchPayload = _lodash2.default.cloneDeep(payload) || {};

                            watchPayload.response = response;
                            watchPayload.request = {
                              url: DOMAIN + path,
                              headers: headers,
                              method: response.change.type
                            };

                            _context2.prev = 8;

                            if (!CACHE) {
                              _context2.next = 13;
                              break;
                            }

                            _context2.next = 12;
                            return CACHE.handleWatchChange(watchPayload);

                          case 12:
                            watchPayload = _context2.sent;

                          case 13:
                            _context2.next = 18;
                            break;

                          case 15:
                            _context2.prev = 15;
                            _context2.t0 = _context2["catch"](8);

                            console.log(_context2.t0);

                          case 18:
                            if (!callback) {
                              _context2.next = 27;
                              break;
                            }

                            _context2.prev = 19;
                            _context2.next = 22;
                            return callback(watchPayload);

                          case 22:
                            _context2.next = 27;
                            break;

                          case 24:
                            _context2.prev = 24;
                            _context2.t1 = _context2["catch"](19);
                            throw _context2.t1;

                          case 27:
                            return _context2.abrupt("return");

                          case 28:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this, [[8, 15], [19, 24]]);
                  }));

                  function handleWatchResponse(_x4) {
                    return _ref6.apply(this, arguments);
                  }

                  return handleWatchResponse;
                }());
              } else {
                return;
                /*
                // Ping a normal GET every 5 seconds in the absense of a websocket
                return setInterval(() => {
                  get({ url: DOMAIN + path }).then(result => {
                    func(payload);
                  });
                }, 5000);
                */
              }
            };

            _replaceLinks = function _replaceLinks(obj) {
              var ret = Array.isArray(obj) ? [] : {};
              if (!obj) return obj; // no defined objriptors for this level
              return Promise.map((0, _keys2.default)(obj || {}), function (key) {
                if (key === "*") {
                  // Don't put *s into oada. Ignore them
                  return;
                }
                var val = obj[key];
                if ((typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val)) !== "object" || !val) {
                  ret[key] = val; // keep it asntType: 'application/vnd.oada.harvest.1+json'
                  return;
                }
                if (val._type) {
                  // If it has a '_type' key, don't worry about it.
                  //It'll get created in future iterations of ensureTree
                  return;
                }
                if (val._id) {
                  // If it's an object, and has an '_id', make it a link from descriptor
                  ret[key] = { _id: val._id };
                  if ('_rev' in val) ret[key]._rev = val._rev;
                  return;
                }
                // otherwise, recurse into the object looking for more links
                return _replaceLinks(val).then(function (result) {
                  ret[key] = result;
                  return;
                });
              }).then(function () {
                return ret;
              });
            };

            if (domain) {
              _context26.next = 13;
              break;
            }

            throw new Error("domain undefined");

          case 13:
            if (!(typeof domain !== "string")) {
              _context26.next = 15;
              break;
            }

            throw new Error("domain must be a string");

          case 15:
            if (!(!options && !token)) {
              _context26.next = 17;
              break;
            }

            throw new Error("options and token undefined");

          case 17:
            if (!(token && typeof token !== "string")) {
              _context26.next = 19;
              break;
            }

            throw new Error("token must be a string");

          case 19:
            if (!(cache !== undefined && typeof cache !== "boolean" && (typeof cache === "undefined" ? "undefined" : (0, _typeof3.default)(cache)) !== "object")) {
              _context26.next = 21;
              break;
            }

            throw new Error("cache must be either a boolean or an object with 'name' and/or 'expires' keys");

          case 21:
            if (!(cache && cache.name && typeof cache.name !== "string")) {
              _context26.next = 23;
              break;
            }

            throw new Error("cache name must be a string");

          case 23:
            if (!(typeof websocket !== "undefined" && typeof websocket !== "boolean")) {
              _context26.next = 25;
              break;
            }

            throw new Error("websocket must be boolean");

          case 25:
            REQUEST = axios;
            NOCACHEREQUEST = axios;
            _token = new _TOKEN({ domain: domain, token: token, options: options });

            if (domain) {
              _context26.next = 30;
              break;
            }

            throw new Error("domain undefined");

          case 30:
            DOMAIN = domain;
            NAME = cache && cache.name ? cache.name : urlLib.parse(domain).hostname.replace(/\./g, "_");
            EXPIRES = cache && cache.expires ? cache.expires : undefined;

            // Filter changes to match the given tree. Handle changes that include link creation.
            // THIS IS BROKEN


            // Loop over the keys of the path and determine whether the object at that level
            // contains a * key. The path must be updated along the way, replacing *s as
            // necessary.

            _context26.next = 35;
            return _token.get();

          case 35:
            TOKEN = _context26.sent;

            if (!(websocket !== false)) {
              _context26.next = 45;
              break;
            }

            _context26.next = 39;
            return ws(domain);

          case 39:
            socketApi = _context26.sent;

            NOCACHEREQUEST = socketApi.http;
            REQUEST = socketApi.http;
            _context26.next = 44;
            return socketApi;

          case 44:
            SOCKET = _context26.sent;

          case 45:
            if (!(cache !== false)) {
              _context26.next = 48;
              break;
            }

            _context26.next = 48;
            return _configureCache({
              name: NAME || (0, _uuid2.default)(),
              req: REQUEST,
              expires: EXPIRES
            });

          case 48:
            return _context26.abrupt("return", {
              token: TOKEN,
              cache: CACHE ? CACHE : false,
              websocket: SOCKET ? SOCKET : false,
              get: get,
              put: put,
              post: post,
              delete: del,
              resetCache: resetCache,
              disconnect: disconnect,
              reconnect: reconnect,
              _getMemoryCache: _getMemoryCache
            });

          case 49:
          case "end":
            return _context26.stop();
        }
      }
    }, _callee26, this);
  }));

  function connect(_x) {
    return _ref2.apply(this, arguments);
  }

  return connect;
}();

exports.default = {
  connect: connect
};