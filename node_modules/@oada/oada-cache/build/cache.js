"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require("babel-runtime/helpers/defineProperty");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

exports.default = setupCache;

var _pouchdb = require("pouchdb");

var _pouchdb2 = _interopRequireDefault(_pouchdb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cq = require("concurrent-queue");
var pretty = require("prettyjson");
var Promise = require("bluebird");

var url = require("url");
var _ = require("lodash");
var pointer = require("json-pointer");
var OFFLINE = false;
var REVLIMIT = 10;
var memoryCache = {};
var timeThreshold = 30000;
var cleanMemoryTimer = 10000;
var dbPutDelay = 5000; // 5 sec
Promise.config({ cancellation: true });

//const error = require('debug')('oada-cache:cache:error');
//const info = require('debug')('oada-cache:cache:info');

function setupCache(_ref) {
  var _ref20;

  /** Get the resource and merge data if its already in the db. */

  /**
   * Store (upsert) resource to local DB
   * @param req request
   * @param waitTime wait time
   */
  var dbUpsert = function () {
    var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(req, waitTime) {
      var urlObj, pieces, resourceId, pathLeftover, dbPut, memoryResult, result, curData, newData;
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              urlObj = url.parse(req.url);
              pieces = urlObj.path.split("/");
              resourceId = pieces.slice(1, 3).join("/"); //returns resources/abc

              pathLeftover = pieces.length > 3 ? "/" + pieces.slice(3, pieces.length).join("/") : "";

              // Create the content to put in the cache

              dbPut = {
                _id: resourceId,
                valid: req.valid === undefined ? true : req.valid,
                // TODO: This current resets this access date for e.g., every put
                // while offline. This doesn't seem right. I think this should only
                // get updated when we know we're upserting a new value from the server
                accessed: Date.now(),
                doc: {}
              };

              // ALL updates to existing docs (upserts) need to supply the current _rev.

              memoryResult = memoryCache[resourceId]; // Try to get resource from in-memory cache

              result = { doc: {} };

              if (memoryResult) {
                _context2.next = 23;
                break;
              }

              _context2.prev = 8;
              _context2.next = 11;
              return db.get(resourceId);

            case 11:
              result = _context2.sent;
              _context2.next = 21;
              break;

            case 14:
              _context2.prev = 14;
              _context2.t0 = _context2["catch"](8);

              if (!(req.method && req.method.toLowerCase() === "delete")) {
                _context2.next = 20;
                break;
              }

              return _context2.abrupt("return");

            case 20:
              if (pathLeftover) {
                dbPut.INCOMPLETE_RESOURCE = true;
              }

            case 21:
              _context2.next = 25;
              break;

            case 23:
              result = memoryResult.data;
              // If in memory, result._rev might be undefined (409 errors)
              if (result._rev !== undefined) dbPut._rev = result._rev;

            case 25:
              if (!(req.method && req.method.toLowerCase() === "delete")) {
                _context2.next = 35;
                break;
              }

              if (pathLeftover) {
                _context2.next = 32;
                break;
              }

              if (memoryCache[resourceId] && memoryCache[resourceId].promise) memoryCache[resourceId].promise.cancel();
              delete memoryCache[resourceId];
              return _context2.abrupt("return", db.remove(result).then(function (response) {
                return { response: response };
              }).catch(function (error) {
                //its okay if it already doesn't exist
                if (error.status === 404) return;
                throw error;
              }));

            case 32:
              if (pointer.has(result.doc, pathLeftover)) {
                dbPut.doc = result.doc;
                pointer.remove(dbPut.doc, pathLeftover);
              }

            case 33:
              _context2.next = 36;
              break;

            case 35:
              //handle "merge" type operations
              if (pathLeftover) {
                curData = pointer.has(result.doc, pathLeftover) ? pointer.get(result.doc, pathLeftover) : {};
                newData = _.merge(curData, req.data || {});

                pointer.set(result.doc, pathLeftover, newData);
                dbPut.doc = result.doc;
              } else {
                dbPut.doc = _.merge(result.doc, req.data);
              }

            case 36:

              if (req._rev != undefined) dbPut.doc._rev = req._rev;
              return _context2.abrupt("return", handleMemoryCache(resourceId, dbPut, waitTime, req));

            case 38:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[8, 14]]);
    }));

    return function dbUpsert(_x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }();

  /**
   * Get resource from the server
   * @param req request
   */


  var getResFromServer = function () {
    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(req) {
      var res;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return request({
                method: "GET",
                url: req.url,
                headers: req.headers
              });

            case 2:
              res = _context3.sent;

              res.cached = false;
              req.data = res.data;
              _context3.prev = 5;
              _context3.next = 8;
              return dbUpsert(req);

            case 8:
              _context3.next = 13;
              break;

            case 10:
              _context3.prev = 10;
              _context3.t0 = _context3["catch"](5);

              console.log('getResFromServerError', _context3.t0);

            case 13:
              return _context3.abrupt("return", res);

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[5, 10]]);
    }));

    return function getResFromServer(_x4) {
      return _ref4.apply(this, arguments);
    };
  }();

  // Create a queue of actual PUTs to make when online.
  // Resource breaks are known via setupTree.
  // Do the puts, save out the resource IDs, and return to client
  // Create an index on the data to find those that need synced

  // Create a service that other apps can run which starts up and periodically
  // checks if a connections has yet been made. A periodic service may also
  // concievably check for updates to cached things.
  //
  // The cache should go "stale" after some period of time; However, if it cannot
  // establish a connection, it should remain valid, usable data.

  /**
   * Get resource from local DB. If the specified resource does not exist, try to get it from the server.
   * @param {any} req request
   * @param {any} offline default is false (online)
   */
  var getResFromDb = function () {
    var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(req) {
      var offline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var revLimit = arguments[2];
      var urlObj, pieces, resourceId, pathLeftover, resource, rev, res_inmemory, res_localdb, data;
      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              urlObj = url.parse(req.url);
              pieces = urlObj.path.split("/");
              resourceId = pieces.slice(1, 3).join("/"); //returns resources/abc

              pathLeftover = pieces.length > 3 ? "/" + pieces.slice(3, pieces.length).join("/") : "";
              resource = undefined;
              rev = undefined;
              // 1) Get resource from in-memory cache

              res_inmemory = memoryCache[resourceId];

              if (res_inmemory) {
                resource = res_inmemory.data;
              }

              // 2) Get resource from local DB

              if (resource) {
                _context5.next = 18;
                break;
              }

              _context5.prev = 9;
              _context5.next = 12;
              return db.get(resourceId);

            case 12:
              res_localdb = _context5.sent;

              resource = res_localdb;
              _context5.next = 18;
              break;

            case 16:
              _context5.prev = 16;
              _context5.t0 = _context5["catch"](9);

            case 18:
              if (!(!resource && !offline)) {
                _context5.next = 22;
                break;
              }

              return _context5.abrupt("return", getResFromServer(req));

            case 22:
              if (!(!resource && offline)) {
                _context5.next = 24;
                break;
              }

              throw "Offline and resource not found in local db.";

            case 24:
              if (!(resource.accessed + expiration <= Date.now() || resource.valid === false)) {
                _context5.next = 29;
                break;
              }

              if (!offline) {
                _context5.next = 28;
                break;
              }

              _context5.next = 29;
              break;

            case 28:
              return _context5.abrupt("return", getResFromServer(req));

            case 29:
              if (!(req.headers && req.headers['x-oada-rev'] && parseInt(req.headers['x-oada-rev']) - parseInt(resource.doc._rev) >= revLimit)) {
                _context5.next = 31;
                break;
              }

              return _context5.abrupt("return", getResFromServer(req));

            case 31:
              if (!pointer.has(resource.doc, pathLeftover)) {
                _context5.next = 36;
                break;
              }

              data = pointer.get(resource.doc, pathLeftover);
              return _context5.abrupt("return", {
                data: data,
                headers: {
                  "x-oada-rev": resource.doc._rev,
                  "content-location": resourceId + pathLeftover
                },
                status: 200,
                cached: true
              });

            case 36:
              return _context5.abrupt("return", getResFromServer(req));

            case 37:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this, [[9, 16]]);
    }));

    return function getResFromDb(_x6) {
      return _ref6.apply(this, arguments);
    };
  }();

  // Accepts an axios-style request. Returns:
  // {
  //
  //   data: the data requested,
  //
  //   _rev: the rev of the parent resource requested
  //
  //   location: e.g.: /resources/abc123/some/path/leftover
  //
  // }


  var get = function () {
    var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(req, revLimit) {
      var urlObj, newReq, lookup;
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              urlObj = url.parse(req.url);
              newReq = _.cloneDeep(req);

              if (!(!/^\/resources/.test(urlObj.path) || !/^\/users/.test(urlObj.path))) {
                _context6.next = 7;
                break;
              }

              _context6.next = 5;
              return getLookup(req);

            case 5:
              lookup = _context6.sent;

              newReq.url = urlObj.protocol + "//" + urlObj.host + "/" + lookup.resourceId + lookup.pathLeftover;

            case 7:
              return _context6.abrupt("return", getResFromDb(newReq, OFFLINE, revLimit || REVLIMIT).then(function (response) {
                return response;
              }));

            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    return function get(_x7, _x8) {
      return _ref7.apply(this, arguments);
    };
  }();

  // TODO: Need to update the cache for both the parent resource and child new
  // resource if one is created


  var put = function () {
    var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(req) {
      var offline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var urlObj, lookup, response;
      return _regenerator2.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              urlObj = url.parse(req.url);

              if (!offline) {
                _context7.next = 7;
                break;
              }

              _context7.next = 4;
              return getLookup({
                url: urlObj.protocol + "//" + urlObj.host + reqPieces.slice(0, reqPieces.length - 1).join("/"),
                headers: req.headers
              });

            case 4:
              lookup = _context7.sent;
              _context7.next = 13;
              break;

            case 7:
              _context7.next = 9;
              return request(req);

            case 9:
              response = _context7.sent;
              _context7.next = 12;
              return dbUpsert({
                url: response.headers["content-location"],
                data: req.data,
                _rev: parseInt(response.headers["x-oada-rev"]),
                // TODO: should it be invalidated until pulled from server?
                valid: false
              });

            case 12:
              return _context7.abrupt("return", response);

            case 13:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    return function put(_x10) {
      return _ref8.apply(this, arguments);
    };
  }();

  // Remove the deleted key from the parent resource optimistically using
  // put(). Also mark the parent invalid as the _rev update will affect it


  var updateParent = function () {
    var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(req) {
      var urlObj, reqPieces, lookup;
      return _regenerator2.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              urlObj = url.parse(req.url);
              // Try to get the parent document

              reqPieces = urlObj.path.split("/");
              _context8.next = 4;
              return getLookup({
                url: urlObj.protocol + "//" + urlObj.host + reqPieces.slice(0, reqPieces.length - 1).join("/"),
                headers: req.headers
              });

            case 4:
              lookup = _context8.sent;
              _context8.next = 7;
              return dbUpsert({
                url: "/" + lookup.resourceId + lookup.pathLeftover + "/" + reqPieces[reqPieces.length - 1],
                method: "delete",
                valid: false
              });

            case 7:
              return _context8.abrupt("return");

            case 8:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    return function updateParent(_x11) {
      return _ref9.apply(this, arguments);
    };
  }();

  var removeLookup = function () {
    var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(lookup) {
      return _regenerator2.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              // Clear the in-memory cache
              if (memoryCache[lookup._id]) {
                if (memoryCache[lookup._id].promise) memoryCache[lookup._id].promise.cancel();
                delete memoryCache[lookup._id];
              }

              _context9.prev = 1;
              _context9.next = 4;
              return db.remove(lookup);

            case 4:
              _context9.next = 11;
              break;

            case 6:
              _context9.prev = 6;
              _context9.t0 = _context9["catch"](1);

              if (!(_context9.t0.status === 404)) {
                _context9.next = 10;
                break;
              }

              return _context9.abrupt("return");

            case 10:
              throw _context9.t0;

            case 11:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this, [[1, 6]]);
    }));

    return function removeLookup(_x12) {
      return _ref10.apply(this, arguments);
    };
  }();

  // Issue DELETE to server then update the db


  var del = function () {
    var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(req, offline) {
      var urlObj, lookup, response;
      return _regenerator2.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              //info('delete:', req.url, req);
              urlObj = url.parse(req.url);
              // Handle resource deletion

              if (!(/^\/resources/.test(urlObj.path) || /^\/users/.test(urlObj.path))) {
                _context10.next = 6;
                break;
              }

              _context10.next = 4;
              return dbUpsert({
                url: req.url,
                method: req.method,
                valid: false
              });

            case 4:
              _context10.next = 30;
              break;

            case 6:
              _context10.prev = 6;
              _context10.next = 9;
              return getLookup(req);

            case 9:
              lookup = _context10.sent;
              _context10.next = 12;
              return dbUpsert({
                url: '/' + lookup.resourceId + lookup.pathLeftover,
                method: req.method,
                valid: false
              });

            case 12:
              _context10.next = 14;
              return removeLookup(lookup);

            case 14:
              _context10.prev = 14;
              _context10.next = 17;
              return updateParent(req);

            case 17:
              _context10.next = 22;
              break;

            case 19:
              _context10.prev = 19;
              _context10.t0 = _context10["catch"](14);
              throw _context10.t0;

            case 22:
              _context10.next = 30;
              break;

            case 24:
              _context10.prev = 24;
              _context10.t1 = _context10["catch"](6);

              if (!(_context10.t1.response && _context10.t1.response.status === 404)) {
                _context10.next = 29;
                break;
              }

              _context10.next = 30;
              break;

            case 29:
              throw _context10.t1;

            case 30:
              if (offline) {
                _context10.next = 36;
                break;
              }

              _context10.next = 33;
              return request(req);

            case 33:
              response = _context10.sent;
              _context10.next = 36;
              break;

            case 36:
              return _context10.abrupt("return", response);

            case 37:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this, [[6, 24], [14, 19]]);
    }));

    return function del(_x13, _x14) {
      return _ref11.apply(this, arguments);
    };
  }();

  var _recursiveUpsert = function () {
    var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13(req, body) {
      var lookup, newBody;
      return _regenerator2.default.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (!(body._rev !== undefined)) {
                _context13.next = 7;
                break;
              }

              _context13.next = 3;
              return getLookup({
                url: req.url,
                headers: req.headers,
                resourceId: body._id
              });

            case 3:
              lookup = _context13.sent;
              newBody = replaceLinks(body, {
                url: req.url,
                headers: req.headers
              });
              _context13.next = 7;
              return dbUpsert({
                url: "/" + (body._id || lookup.resourceId),
                data: newBody
              });

            case 7:
              if (!((typeof body === "undefined" ? "undefined" : (0, _typeof3.default)(body)) === "object")) {
                _context13.next = 11;
                break;
              }

              return _context13.abrupt("return", Promise.map((0, _keys2.default)(body || {}), function () {
                var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12(key) {
                  return _regenerator2.default.wrap(function _callee12$(_context12) {
                    while (1) {
                      switch (_context12.prev = _context12.next) {
                        case 0:
                          if (!(key.charAt(0) === "_")) {
                            _context12.next = 2;
                            break;
                          }

                          return _context12.abrupt("return");

                        case 2:
                          if (body[key]) {
                            _context12.next = 4;
                            break;
                          }

                          return _context12.abrupt("return");

                        case 4:
                          _context12.next = 6;
                          return _recursiveUpsert({
                            url: req.url + "/" + key,
                            headers: req.headers
                          }, body[key]);

                        case 6:
                        case "end":
                          return _context12.stop();
                      }
                    }
                  }, _callee12, this);
                }));

                return function (_x19) {
                  return _ref14.apply(this, arguments);
                };
              }()));

            case 11:
              return _context13.abrupt("return");

            case 12:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    return function _recursiveUpsert(_x17, _x18) {
      return _ref13.apply(this, arguments);
    };
  }();

  /*
  async function _recursiveUpsert(req, body, oldBody) {
  if (body._rev) {
      let lookup = await getLookup({
        url: req.url,
        headers: req.headers,
        _id: body._id
      })
      let newBody = replaceLinks(body, {
        url: req.url,
        headers: req.headers
      });
    var result = await dbUpsert({
        url: '/'+(body._id || lookup.resourceId),
        data: newBody,
      })
      oldBody = result.oldBody;
    }
  
    if (typeof body === 'object') {
      return Promise.map(Object.keys(body || {}), async function(key) {
        if (key.charAt(0) === '_') return
        if (!body[key]) return
        var oldPiece = await _recursiveUpsert({
          url: req.url+'/'+key,
          headers: req.headers
        }, body[key], oldBody[key])
        oldBody[key] = oldPiece;
      }).then(() => {
        return oldBody
      })
    } else return;
  }*/

  var resetCache = function () {
    var _ref18 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee18() {
      return _regenerator2.default.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              _context18.prev = 0;

              if (!db) {
                _context18.next = 6;
                break;
              }

              (0, _keys2.default)(memoryCache).forEach(function () {
                var _ref19 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee17(key) {
                  return _regenerator2.default.wrap(function _callee17$(_context17) {
                    while (1) {
                      switch (_context17.prev = _context17.next) {
                        case 0:
                          if (!memoryCache[key].promise) {
                            _context17.next = 3;
                            break;
                          }

                          _context17.next = 3;
                          return memoryCache[key].promise.cancel();

                        case 3:
                        case "end":
                          return _context17.stop();
                      }
                    }
                  }, _callee17, this);
                }));

                return function (_x22) {
                  return _ref19.apply(this, arguments);
                };
              }());
              memoryCache = {};
              _context18.next = 6;
              return db.destroy();

            case 6:
              _context18.next = 11;
              break;

            case 8:
              _context18.prev = 8;
              _context18.t0 = _context18["catch"](0);
              return _context18.abrupt("return");

            case 11:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this, [[0, 8]]);
    }));

    return function resetCache() {
      return _ref18.apply(this, arguments);
    };
  }();

  var name = _ref.name,
      req = _ref.req,
      expires = _ref.expires;

  // name should be made unique across domains and users
  var db = db || new _pouchdb2.default(name);
  // This fixes concurrent accesses
  _pouchdb2.default.on("destroyed", function () {
    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(dbName) {
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (dbName === name) {
                db = new _pouchdb2.default(name);
              }

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }());
  var request = req;
  var expiration = expires || 1000 * 60 * 60 * 24 * 2; //(ms/s)*(s/min)*(min/hr)*(hr/days)*days

  // Clean in-memory cache periodically
  setInterval(cleanMemoryCache, cleanMemoryTimer);

  function cleanMemoryCache() {
    var now = Date.now();
    var oldest = { key: undefined, time: now };
    var deleteCount = 0;
    (0, _keys2.default)(memoryCache).forEach(function (key) {
      if (!memoryCache[key].promise && now - memoryCache[key].access < timeThreshold) {
        if (memoryCache[key].access < oldest) {
          oldest = { key: key, time: memoryCache[key].access };
        }
        delete memoryCache[key];
        deleteCount++;
      }
    });

    if (deleteCount === 0 && oldest.key) {
      delete memoryCache[oldest.key];
    }
  }

  /** Save resource to in-memory cache and schedule PUT */
  function handleMemoryCache(resourceId, data, waitTime, req) {
    var now = Date.now();
    if (resourceId in memoryCache) {
      // resource exists in in-cache memory
      // update data and access time
      memoryCache[resourceId].data = data;
      memoryCache[resourceId].access = now;
    } else {
      // resource does not exist
      // add new resource
      memoryCache[resourceId] = {
        data: data,
        access: now,
        promise: undefined
      };
    }

    // Schedule db.put
    if (!memoryCache[resourceId].promise) {
      // Schedule put
      memoryCache[resourceId].promise = Promise.delay(dbPutDelay).then(function () {
        doPut(resourceId, waitTime, req);
      }).catch(function (error) {
        console.log('handleMemoryCacheError', error);
      });
    }
    return Promise.resolve();
  }

  /**  Get resource from in-memory cache and do put to Pouch DB */
  function doPut(resourceId, waitTime, req) {
    if (!memoryCache[resourceId].data._rev) return;
    return db.put(memoryCache[resourceId].data).then(function (response) {
      memoryCache[resourceId].data._rev = response.rev;
      delete memoryCache[resourceId].promise;
    }).catch(function (err) {
      console.log("Error doPut", memoryCache[resourceId].data._rev, err);
      // TODO: Handle this error
      // retry 409s
      // if (err.status === 409) {
      //   waitTime = waitTime || 1000;
      //   return Promise.delay(waitTime).then(() => {
      //     if (waitTime > 16000) throw err;
      //     return dbUpsert(req, waitTime * 2);
      //   });
      // }
      //throw err;
    });
  }

  function _getMemoryCache() {
    return memoryCache;
  }

  // Perform lookup from bookmarks to resource id (and path leftover) mapping.
  // If the lookup fails, use a HEAD request to get it from the server and put
  // it in the cache. An optional _id can be passed into req to force creation
  // of a particular lookup in the event that the resource doesn't yet exist but will.
  // This is primarily for when links are created before the resource itself has been.
  function getLookup(req) {
    var urlObj = url.parse(req.url);
    var res_inmemory = memoryCache[urlObj.path];
    if (res_inmemory) {
      return res_inmemory.data;
    } else {
      // not in memory  
      return db.get(urlObj.path).catch((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
        var resourceId, pathLeftover, headReq, response, pieces, data;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!req.resourceId) {
                  _context4.next = 5;
                  break;
                }

                resourceId = req.resourceId;
                pathLeftover = "";
                _context4.next = 13;
                break;

              case 5:
                // normal case, not recursiveUpsert
                //info('getLookup - HEAD request:', req.url, req)
                headReq = _.cloneDeep(req);

                headReq.method = "HEAD";
                _context4.next = 9;
                return request(headReq);

              case 9:
                response = _context4.sent;

                //info('getLookup - HEAD response:', response)
                //Save the url lookup for future use
                pieces = response.headers["content-location"].split("/");

                resourceId = pieces.slice(1, 3).join("/"); //returns resources/abc
                pathLeftover = pieces.length > 3 ? "/" + pieces.slice(3, pieces.length).join("/") : "";

              case 13:
                // Put the new lookup
                data = {
                  _id: urlObj.path,
                  resourceId: resourceId,
                  pathLeftover: pathLeftover
                };
                return _context4.abrupt("return", handleMemoryCache(urlObj.path, data, undefined, req).then(function () {
                  return getLookup(req);
                }));

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      })));
    }
  }

  function replaceLinks(obj, req) {
    var ret = Array.isArray(obj) ? [] : {};
    if (!obj) return obj;
    (0, _keys2.default)(obj || {}).forEach(function () {
      var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(key, i) {
        var val, lookup;
        return _regenerator2.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                val = obj[key];

                if (!((typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val)) !== "object" || !val)) {
                  _context11.next = 4;
                  break;
                }

                ret[key] = val; // keep it asntType: 'application/vnd.oada.harvest.1+json'
                return _context11.abrupt("return");

              case 4:
                if (!val._meta) {
                  _context11.next = 11;
                  break;
                }

                _context11.next = 7;
                return getLookup({
                  url: req.url + "/" + key,
                  headers: req.headers
                });

              case 7:
                lookup = _context11.sent;

                ret[key] = { _id: lookup.resourceId };
                if (obj[key]._rev !== undefined) ret[key]._rev = obj[key]._rev;
                return _context11.abrupt("return");

              case 11:
                ret[key] = replaceLinks(obj[key], {
                  url: req.url + "/" + key,
                  headers: req.headers
                }); // otherwise, recurse into the object

              case 12:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function (_x15, _x16) {
        return _ref12.apply(this, arguments);
      };
    }());
    return ret;
  }

  function findNullValue(obj, path, nullPath) {
    if ((typeof obj === "undefined" ? "undefined" : (0, _typeof3.default)(obj)) === "object") {
      return Promise.map((0, _keys2.default)(obj || {}), function (key) {
        if (obj[key] === null) {
          nullPath = path + "/" + key;
          return nullPath;
        }
        return findNullValue(obj[key], path + "/" + key, nullPath).then(function (res) {
          nullPath = res || nullPath;
          return res || nullPath;
        });
      }, { concurrency: 1 }).then(function () {
        return nullPath;
      }).catch(function (err) {
        return;
      });
    } else {
      return Promise.resolve(undefined);
    }
  }

  /*
  async function _upsertChangeArray(payload) {
    let urlObj = url.parse(payload.request.url);
    return Promise.map(payload.response.changes || [], async (change) => {
      if (change.type === 'merge') {
        return dbUpsert({
          url: urlObj.protocol+'//'+urlObj.host+'/'+change._id,
          data: change.body,
        })
      } else if (change.type === 'delete') {
        var nullPath = await findNullValue(change.body, '', '')
        return dbUpsert({
          url: urlObj.protocol+'//'+urlObj.host+'/'+change._id+nullPath,
          data: change.body,
        })
      }
    })
  }
  */

  // Will this handle watches put on keys of a resource? i.e., no _id to be found
  function findDeepestResource(obj, path, deepestResource) {
    if ((typeof obj === "undefined" ? "undefined" : (0, _typeof3.default)(obj)) === "object") {
      return Promise.map((0, _keys2.default)(obj || {}), function (key) {
        // _rev updates guaranteed to be present in change docs for affected resources
        if (key === "_rev") {
          deepestResource.path = path;
          deepestResource.data = obj;
        } else if (key.charAt(0) === "_") return deepestResource;
        return findDeepestResource(obj[key], path + "/" + key, deepestResource).then(function () {
          return deepestResource;
        });
      }).then(function () {
        return deepestResource;
      });
    }
    return Promise.resolve(deepestResource);
  }

  var queue = cq().limit({ concurrency: 1 }).process(function () {
    var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee16(payload) {
      var _this = this;

      var urlObj;
      return _regenerator2.default.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              urlObj = url.parse(payload.request.url);
              // Give the change body an _id so the deepest resource can be found

              payload.response.change.body._id = payload.response.resourceId;
              //TODO: This should be unnecessary. The payload ought to specify the root
              //of the watch as a resource.
              return _context16.abrupt("return", findDeepestResource(payload.response.change.body, "", {
                path: "",
                data: payload.response.change.body
              }).then(function () {
                var _ref16 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15(deepestResource) {
                  var nullPath, deletedPath;
                  return _regenerator2.default.wrap(function _callee15$(_context15) {
                    while (1) {
                      switch (_context15.prev = _context15.next) {
                        case 0:
                          if (!payload.response.change.wasDelete) {
                            _context15.next = 9;
                            break;
                          }

                          _context15.next = 3;
                          return findNullValue(deepestResource.data, "", "");

                        case 3:
                          nullPath = _context15.sent;
                          deletedPath = deepestResource.path + nullPath;

                          payload.nullPath = deletedPath;
                          return _context15.abrupt("return", dbUpsert({
                            url: payload.request.url + deletedPath,
                            headers: payload.request.headers,
                            method: "delete",
                            valid: true
                          }).then((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14() {
                            return _regenerator2.default.wrap(function _callee14$(_context14) {
                              while (1) {
                                switch (_context14.prev = _context14.next) {
                                  case 0:
                                    return _context14.abrupt("return", payload);

                                  case 1:
                                  case "end":
                                    return _context14.stop();
                                }
                              }
                            }, _callee14, this);
                          }))));

                        case 9:
                          _context15.next = 11;
                          return _recursiveUpsert(payload.request, payload.response.change.body, {});

                        case 11:
                          return _context15.abrupt("return", payload);

                        case 12:
                        case "end":
                          return _context15.stop();
                      }
                    }
                  }, _callee15, _this);
                }));

                return function (_x21) {
                  return _ref16.apply(this, arguments);
                };
              }()).catch(function (err) {
                return payload;
              }));

            case 3:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    return function (_x20) {
      return _ref15.apply(this, arguments);
    };
  }());

  function handleWatchChange(payload) {
    return queue(payload);
  }

  var api = function handleRequest(req) {
    switch (req.method) {
      case "get":
        return get(req);
      case "delete":
        return del(req);
      case "put":
        return put(req);
    }
  };

  return _ref20 = {
    api: api,
    db: db,
    resetCache: resetCache,
    handleWatchChange: handleWatchChange,
    removeLookup: removeLookup,
    findDeepestResource: findDeepestResource,
    findNullValue: findNullValue,
    getLookup: getLookup,
    dbUpsert: dbUpsert,
    handleMemoryCache: handleMemoryCache,
    doPut: doPut,
    _recursiveUpsert: _recursiveUpsert
  }, (0, _defineProperty3.default)(_ref20, "findNullValue", findNullValue), (0, _defineProperty3.default)(_ref20, "replaceLinks", replaceLinks), (0, _defineProperty3.default)(_ref20, "removeLookup", removeLookup), (0, _defineProperty3.default)(_ref20, "updateParent", updateParent), (0, _defineProperty3.default)(_ref20, "getResFromDb", getResFromDb), (0, _defineProperty3.default)(_ref20, "getResFromServer", getResFromServer), (0, _defineProperty3.default)(_ref20, "_getMemoryCache", _getMemoryCache), _ref20;
}