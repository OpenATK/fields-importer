'use strict';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Promise = require('bluebird');
var urlLib = require('url');
var uuid = require('uuid/v4');
var WebSocket = require('isomorphic-ws');
//const error = require('debug')('oada-cache:websocket:error');
//const info = require('debug')('oada-cache:websocket:info');
Promise.config({ warnings: false });

function websocket(url) {
	//Create the message queue
	var messages = [];
	//Create the socket
	url = url.replace('https://', 'wss://').replace('http://', 'ws://');
	var socket = new WebSocket(url);
	var connected = false;
	var httpCallbacks = {};
	var watchCallbacks = {};

	function sendMessages() {
		if (!connected) return;
		messages.forEach(function (message) {
			socket.send((0, _stringify2.default)(message));
		});
		messages = [];
	}

	return new Promise(function (resolve, reject) {
		socket.onopen = function (event) {
			connected = true;
			sendMessages();
			resolve(socket);
		};

		socket.onclose = function (event) {};
		socket.onmessage = function (event) {
			var response = JSON.parse(event.data);
			//Look for id in httpCallbacks
			if (response.requestId) {
				if (httpCallbacks[response.requestId]) {
					//Resolve Promise
					if (response.status >= 200 && response.status < 300) {
						httpCallbacks[response.requestId].resolve(response);
					} else {
						//Create error like axios
						var err = new Error('Request failed with status code ' + response.status);
						err.request = httpCallbacks[response.requestId].request;
						err.response = {
							status: response.status,
							statusText: response.statusText,
							headers: response.headers,
							data: response.data
						};
						err.originalStack = httpCallbacks[response.requestId].request.requestStack;

						httpCallbacks[response.requestId].reject(err);
					}
					delete httpCallbacks[response.requestId];
				} else if (watchCallbacks[response.requestId]) {
					if (watchCallbacks[response.requestId].resolve) {
						if (response.status === 'success') {
							//Successfully setup websocket, resolve promise
							watchCallbacks[response.requestId].resolve(response);
						} else {
							//error(watchCallbacks[response.requestId].request, response);
							var _err = new Error('Request failed with status code ' + response.status);
							_err.response = response;
							_err.request = watchCallbacks[response.requestId].request;
							watchCallbacks[response.requestId].reject(_err);
						}
						//Remove resolve and reject so we process change as a signal next time
						delete watchCallbacks[response.requestId]['resolve'];
						delete watchCallbacks[response.requestId]['reject'];
					} else {
						if (watchCallbacks[response.requestId].callback == null) throw new Error('The given watch function has an undefined callback:', watchCallbacks[response.requestId]);
						watchCallbacks[response.requestId].callback(response);
					}
				}
			}
		};
	}).then(function () {

		function _http(request) {
			//Do a HTTP request
			return new Promise(function (resolve, reject) {
				var urlObj = urlLib.parse(request.url);
				var message = {
					requestId: uuid(),
					method: request.method.toLowerCase(),
					path: urlObj.path,
					data: request.data,
					headers: (0, _entries2.default)(request.headers).map(function (_ref) {
						var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
						    key = _ref2[0],
						    value = _ref2[1];

						return (0, _defineProperty3.default)({}, key.toLowerCase(), value);
					}).reduce(function (a, b) {
						return (0, _extends3.default)({}, a, b);
					})
				};
				messages.push(message);
				httpCallbacks[message.requestId] = {
					request: request,
					resolve: resolve,
					reject: reject
				};
				sendMessages();
			});
		}

		function _unwatch(request, callback) {
			//Watch for changes on requested resource and trigger provided signal
			return new Promise(function (resolve, reject) {
				var message = {
					requestId: uuid(),
					method: 'unwatch',
					path: request.path,
					headers: (0, _entries2.default)(request.headers).map(function (_ref4) {
						var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
						    key = _ref5[0],
						    value = _ref5[1];

						return (0, _defineProperty3.default)({}, key.toLowerCase(), value);
					}).reduce(function (a, b) {
						return (0, _extends3.default)({}, a, b);
					})
				};
				messages.push(message);
				watchCallbacks[message.requestId] = { request: request, resolve: resolve, reject: reject, callback: callback };
				sendMessages();
			});
		}

		function _watch(request, callback) {
			//Watch for changes on requested resource and trigger provided signal
			return new Promise(function (resolve, reject) {
				var message = {
					requestId: uuid(),
					method: 'watch',
					path: request.path,
					headers: (0, _entries2.default)(request.headers).map(function (_ref7) {
						var _ref8 = (0, _slicedToArray3.default)(_ref7, 2),
						    key = _ref8[0],
						    value = _ref8[1];

						return (0, _defineProperty3.default)({}, key.toLowerCase(), value);
					}).reduce(function (a, b) {
						return (0, _extends3.default)({}, a, b);
					})
				};
				messages.push(message);
				watchCallbacks[message.requestId] = { request: request, resolve: resolve, reject: reject, callback: callback };
				sendMessages();
			});
		}

		function _close() {
			//TODO reject all callbacks that have not resolved
			//Clear everything
			messages = [];
			httpCallbacks = {};
			watchCallbacks = {};
			//Close socket
			socket.close();
		}

		return {
			url: url,
			http: _http,
			close: _close,
			watch: _watch,
			unwatch: _unwatch
		};
	});
}

module.exports = websocket;